<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Backend Hızlı Rehber</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');

    :root {
      --bg: #0d1d35;
      --panel: #132744;
      --panel-strong: #112138;
      --accent: #82eaff;
      --accent-2: #f6c177;
      --muted: #a7bed3;
      --text: #eef3fb;
      --border: #243552;
      --glow: rgba(130, 234, 255, 0.15);
      --shadow: 0 18px 50px rgba(0, 0, 0, 0.28);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Space Grotesk', 'Inter', system-ui, -apple-system, sans-serif;
      background:
        radial-gradient(circle at 18% 22%, rgba(130, 234, 255, 0.2), transparent 28%),
        radial-gradient(circle at 78% 12%, rgba(246, 193, 119, 0.2), transparent 24%),
        linear-gradient(135deg, #102642 0%, #0f2340 40%, #0d1d35 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 0 1.5rem 3rem;
    }

    .shell {
      max-width: 1200px;
      margin: 0 auto;
      padding-top: 2rem;
    }

    header.hero {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      margin-bottom: 1.5rem;
      padding: 1.35rem 1.4rem;
      background: linear-gradient(145deg, rgba(125, 211, 252, 0.08), rgba(15, 23, 42, 0.9));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
    }

    h1 {
      margin: 0;
      font-size: clamp(1.9rem, 3vw, 2.6rem);
      letter-spacing: -0.02em;
      color: #f8fafc;
    }

    p.lead {
      margin: 0;
      color: var(--muted);
      max-width: 820px;
    }

    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--accent);
      font-weight: 700;
      font-size: 0.8rem;
    }

    .top-nav {
      display: flex;
      gap: 0.55rem;
      flex-wrap: wrap;
      padding: 0.9rem 1rem;
      margin: 0 auto 0.8rem;
      background: var(--panel-strong);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(6px);
    }

    .top-nav a {
      color: var(--text);
      text-decoration: none;
      padding: 0.6rem 1rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      transition: all 150ms ease;
      font-weight: 700;
      font-size: 0.95rem;
    }

    .top-nav a:hover {
      border-color: var(--accent);
      color: #0b1222;
      background: var(--accent);
      box-shadow: 0 6px 18px var(--glow);
    }

    section {
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0 0 1.4rem;
      margin-bottom: 1rem;
      box-shadow: none;
      border-bottom: 1px solid var(--border);
    }

    section h2 {
      margin-top: 0;
      margin-bottom: 0.65rem;
      letter-spacing: -0.01em;
      color: #f8fafc;
    }

    section h3 {
      margin-top: 1.1rem;
      margin-bottom: 0.35rem;
    }

    .section-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.8rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .section-desc {
      margin: 0;
      color: var(--muted);
      max-width: 900px;
    }

    .grid {
      display: grid;
      gap: 0.9rem;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }

    .card {
      background: transparent;
      border: none;
      border-left: 2px solid var(--border);
      border-radius: 0;
      padding: 0.4rem 0 0.4rem 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    table.matrix {
      width: 100%;
      border-collapse: collapse;
      margin: 0.6rem 0;
    }

    table.matrix th,
    table.matrix td {
      border: 1px solid var(--border);
      padding: 0.6rem 0.5rem;
      text-align: left;
    }

    table.matrix th {
      background: var(--panel);
      color: var(--text);
      font-weight: 700;
    }

    table.matrix td {
      color: var(--muted);
      background: rgba(255, 255, 255, 0.02);
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      background: rgba(110, 231, 183, 0.12);
      color: var(--text);
      border: 1px solid rgba(110, 231, 183, 0.35);
      font-size: 0.85rem;
      font-weight: 600;
    }

    ul {
      margin: 0.3rem 0;
      padding-left: 1.1rem;
      color: var(--muted);
    }

    li + li {
      margin-top: 0.25rem;
    }

    .muted {
      color: var(--muted);
    }

    .pill-list {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      margin: 0.4rem 0 0;
    }

    .callout {
      border-left: 4px solid var(--accent);
      padding-left: 0.75rem;
      color: var(--muted);
    }

    .to-top {
      position: fixed;
      right: 1.25rem;
      bottom: 1.25rem;
      padding: 0.65rem 0.95rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      text-decoration: none;
      font-weight: 700;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      transition: all 120ms ease;
      z-index: 20;
    }

    .to-top:hover {
      border-color: var(--accent);
      color: #0f172a;
      background: var(--accent);
    }
  </style>
</head>
<body id="top">
  <div class="shell">
    <header class="hero">
      <div class="eyebrow">Pratik rehber</div>
      <h1>Backend Hızlı Rehber</h1>
      <p class="lead">
        Modern backend için dil seçimi, veri katmanı, dağıtık sistem ve operasyon notları. Ezber yerine saha odaklı, kısa ve akıcı.
      </p>
    </header>

    <nav class="top-nav">
      <a href="#dil-modeli">Dil Çalışma Modeli</a>
      <a href="#dil-secimi">Dil Seçimi</a>
      <a href="#dil-senaryolari">Dil Senaryoları</a>
      <a href="#veri-katmani">Veri Katmanı</a>
      <a href="#servis-akisi">Servis Akışı</a>
      <a href="#dagitik-dayaniklilik">Dağıtık &amp; Dayanıklılık</a>
      <a href="#operasyon">Operasyon</a>
      <a href="#test-yayin">Test &amp; Yayın</a>
      <a href="#guvenlik">Güvenlik</a>
      <a href="#teknik-notlar">Teknik Notlar</a>
      <a href="#kapsam-disi">Kapsam Dışı</a>
      <a href="#not">Not</a>
    </nav>
    <main class="content">

    <section id="dil-modeli">
      <div class="section-head">
        <h2>Dil Çalışma Modeli</h2>
        <p class="section-desc">Derleme/çalıştırma hattı, VM/JIT/bytecode farkları ve nerede güçlü/zayıf olduklarını netleştirmek için.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Derleme/Çalışma Özeti</h3>
          <p class="muted">Statik derlenen diller (Go, Rust, C/C++) doğrudan makine kodu ve çoğu zaman statik linkli tek binary üretir; cold start hızlı, runtime ayak izi küçüktür. VM/bytecode dilleri (Java/Kotlin JVM, C#/.NET CLR, Elixir BEAM) bytecode üretir; VM üzerinde JIT (Just-In-Time) + GC (Garbage Collector) ile çalışır, sıcak kodda hızlanır. Dinamik diller (JavaScript/V8, Python, Ruby, PHP) bytecode/JIT ile optimize olur; başlangıcı kolaydır, CPU-bound yüklerde GC veya GIL (Global Interpreter Lock) gibi sınırlara çabuk dayanır. TypeScript önce JS’e transpile olur, sonra JS runtime’ı çalıştırır.</p>
          <p class="muted">Derleme hattı (statik/JIT): Kaynak → lexer/parser → AST (Abstract Syntax Tree) → IR/SSA (Intermediate Representation / Static Single Assignment) → optimizer → kod üretimi → (statik/dinamik link) → makine kodu. JIT’te ilk aşamada interpreter/baseline JIT çalışır, profil toplandıkça optimize JIT kodu üretilir; hot path hızlanır, cold start daha yavaştır. AOT (Ahead-Of-Time: Native AOT, GraalVM Native, Go/Rust) JIT süresini ortadan kaldırır ama bazı optimizasyonlardan feragat edebilir.</p>
          <p class="muted">Bellek yönetimi: GC (mark-sweep, generational, concurrent) latency’ye ek duraklar getirir; tuning gerek. Ownership (Rust) veya manuel yönetim (C/C++) runtime maliyetini düşürür, hatayı yazılımcıya bırakır. FFI (Foreign Function Interface, C/C++) sınırları ve dynamic dispatch/reflection gibi özellikler performansa etki eder; cold/warm farkını, container cold start’ını ve profil odaklı tuning’i göz önünde bulundur.</p>
        </div>
      </div>
      <h3>Dil / Derleme Modeli Matrisi</h3>
      <table class="matrix">
        <thead>
          <tr>
            <th>Dil</th>
            <th>Derleme/Çalıştırma</th>
            <th>Runtime / Not</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>JavaScript (Node.js)</td>
            <td>JIT (V8), bytecode + optimizasyon; derleme yok.</td>
            <td>Event-loop, tek thread + worker; hızlı start, CPU-bound’da sınırlı.</td>
          </tr>
          <tr>
            <td>TypeScript</td>
            <td>Transpile → JavaScript, sonra V8 JIT.</td>
            <td>TS derlemesi build aşamasında; runtime JS gibi davranır.</td>
          </tr>
          <tr>
            <td>Go</td>
            <td>Statik derleme → tek binary (ELF/PE); linker dahildir.</td>
            <td>GC’li ama hafif runtime; hızlı start, kolay deploy.</td>
          </tr>
          <tr>
            <td>Rust</td>
            <td>LLVM ile statik derleme → makine kodu.</td>
            <td>GC yok, ownership modeli; yüksek performans ve güvenlik.</td>
          </tr>
          <tr>
            <td>Java / Kotlin</td>
            <td>Derleme → JVM bytecode (class/jar); JIT (HotSpot).</td>
            <td>Olgun GC (G1/ZGC), JIT ile uzun soluklu servislerde hızlanır; AOT seçeneği var.</td>
          </tr>
          <tr>
            <td>C# / .NET</td>
            <td>Derleme → IL; JIT (RyuJIT), Native AOT seçeneği.</td>
            <td>CLR GC, cross-platform; AOT ile cold start düşürülebilir.</td>
          </tr>
          <tr>
            <td>Python</td>
            <td>Bytecode (pyc) + yorumlayıcı; JIT yok (CPython).</td>
            <td>GIL nedeniyle CPU-bound sınırlı; C uzantıları veya PyPy/JIT alternatifleri hız kazandırabilir.</td>
          </tr>
          <tr>
            <td>PHP</td>
            <td>Yorumlanır + opcode cache (opcache).</td>
            <td>Hızlı iterasyon, FPM ile çalışır; CPU-bound sınırlı, opcache kritik.</td>
          </tr>
          <tr>
            <td>Ruby</td>
            <td>Yorumlanır (YARV bytecode).</td>
            <td>JIT deneysel; Rails ekosistemiyle üretken ama CPU-bound sınırlı.</td>
          </tr>
          <tr>
            <td>Elixir</td>
            <td>Derleme → BEAM bytecode.</td>
            <td>BEAM VM: hafif process, preemptive scheduler, güçlü fault-tolerance.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="dil-secimi">
      <div class="section-head">
        <h2>Dil Seçimi</h2>
        <p class="section-desc">Senaryoya göre kısa yönlendirme; “nerede parlar / nerede tıkanır” net olsun.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>JavaScript / Node.js</h3>
          <p class="muted">Modern API, realtime, hızlı geliştirme.</p>
          <ul>
            <li><strong>Kullan:</strong> Realtime (WebSocket), çok I/O’lu API’ler, BFF katmanı.</li>
            <li><strong>Güçlü:</strong> NPM ekosistemi, Express/Fastify/NestJS ile hızlı çıkış; tek dilde (JS/TS) uçtan uca.</li>
            <li><strong>Dikkat:</strong> CPU-bound işlerde worker_threads veya ayrı servis kullan; event loop’u bloklama.</li>
          </ul>
        </div>
        <div class="card">
          <h3>TypeScript</h3>
          <p class="muted">JavaScript'in tipli hali → backend için daha güvenli.</p>
          <ul>
            <li><strong>Kullan:</strong> Node.js projelerinde hata payını azaltmak, büyük kod tabanında kontrat netliği.</li>
            <li><strong>Güçlü:</strong> Refactor güveni, IDE otomasyonu, strict mode ile runtime hatalarını erkenden yakalar.</li>
            <li><strong>Dikkat:</strong> Build/tsconfig disiplini şart; tip tanımları ve eslint/tsc pipeline’ını güncel tut.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Golang (Go)</h3>
          <p class="muted">Basit, hızlı, cloud-native, microservice dostu.</p>
          <ul>
            <li><strong>Kullan:</strong> Yüksek trafikli API, altyapı/DevOps araçları, CLI ve worker’lar.</li>
            <li><strong>Güçlü:</strong> Goroutine/scheduler, tek statik binary, güçlü stdlib (net/http, pprof, tracing), hızlı derleme.</li>
            <li><strong>Dikkat:</strong> Generics hâlâ gelişiyor; framework yerine kütüphane toplarsın, error handling manuel.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Rust</h3>
          <p class="muted">Performans, memory güvenliği, güvenli concurrency.</p>
          <ul>
            <li><strong>Kullan:</strong> Performans kritik servis, edge worker, WASM ile API, düşük latency proxy.</li>
            <li><strong>Güçlü:</strong> Ownership/borrow checker ile bellek güvenliği, zero-cost abstraction, async/await ile yüksek throughput.</li>
            <li><strong>Dikkat:</strong> Öğrenme eğrisi dik; build süreleri ve bazı alanlarda ekosistem küçük, ama güvenlik/performans getirisi yüksek.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Java</h3>
          <p class="muted">Olgun JVM ekosistemi, Spring Boot üretim standardı.</p>
          <ul>
            <li><strong>Kullan:</strong> Kurumsal API, entegrasyon hub’ları, uzun ömürlü projeler.</li>
            <li><strong>Güçlü:</strong> Spring Boot ekosistemi, JVM JIT/GC seçenekleri (G1/ZGC), zengin kütüphane ve tooling.</li>
            <li><strong>Dikkat:</strong> Boot süresi ve kaynak kullanımı; container imaj boyutu/GC ayarları ve warm-up’ı izlemek gerekir.</li>
          </ul>
        </div>
        <div class="card">
          <h3>C# / .NET Core</h3>
          <p class="muted">Kurumsal backend, güçlü API mimarisi, cross-platform.</p>
          <ul>
            <li><strong>Kullan:</strong> Enterprise API, yüksek güvenlik ve performans isteyen projeler.</li>
            <li><strong>Güçlü:</strong> ASP.NET Core pipeline, entegre DI, gRPC/REST desteği, zengin tooling (CLI/Rider/VS), cross-platform.</li>
            <li><strong>Dikkat:</strong> Runtime ve container boyutu; trimming/AOT seçeneklerini değerlendir, GC ayarlarını izle.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Python</h3>
          <p class="muted">Hafif API (Flask/FastAPI), data &amp; automation.</p>
          <ul>
            <li><strong>Kullan:</strong> Prototip, AI/ML servisleri, script + API birleşimi, ETL.</li>
            <li><strong>Güçlü:</strong> Zengin bilimsel ekosistem (NumPy/Pandas/PyTorch), hızlı geliştirme, FastAPI/Flask ile hafif API.</li>
            <li><strong>Dikkat:</strong> GIL sebebiyle CPU-bound yavaş; async’te dikkatli ol, ağır işleri C uzantısı veya ayrı servisle çöz.</li>
          </ul>
        </div>
        <div class="card">
          <h3>PHP</h3>
          <p class="muted">Laravel ile klasik web backend kültürü.</p>
          <ul>
            <li><strong>Kullan:</strong> CRUD ağırlıklı web app, monolith hızlı çıkarma, CMS/portal.</li>
            <li><strong>Güçlü:</strong> Laravel ekosistemi, hazır paketler, yaygın hosting; FPM/Nginx ile kolay kurulum.</li>
            <li><strong>Dikkat:</strong> Yüksek trafikte opcache/queue tuning ve cache stratejisi şart; uzun işlemleri job queue’ya al.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Ruby</h3>
          <p class="muted">Rails → modern web framework kültürünün kurucusu.</p>
          <ul>
            <li><strong>Kullan:</strong> Ürün odaklı SaaS, CRUD + dashboard, admin paneller.</li>
            <li><strong>Güçlü:</strong> Rails’in “convention over configuration” yaklaşımı, scaffold, ActiveJob/ActiveRecord, hızlı MVP.</li>
            <li><strong>Dikkat:</strong> Yüksek trafikte cache + job queue (Sidekiq) ve çoklu process (Puma) stratejisi şart.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Elixir</h3>
          <p class="muted">Erlang VM üzerinde yüksek concurrency.</p>
          <ul>
            <li><strong>Kullan:</strong> Realtime, messaging, fault-tolerant servisler, telekom/sohbet.</li>
            <li><strong>Güçlü:</strong> BEAM VM dayanıklılığı, milyonlarca lightweight process, Phoenix ile LiveView/realtime.</li>
            <li><strong>Dikkat:</strong> BEAM deneyimi gerekir; ekosistem niş, fakat üretim dayanıklılığı yüksek.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Kotlin</h3>
          <p class="muted">Java ekosisteminin modern alternatifi. Backend + Android desteği.</p>
          <ul>
            <li><strong>Kullan:</strong> JVM üzerinde modern backend; Android + backend aynı dil, event-driven servisler.</li>
            <li><strong>Güçlü:</strong> Null-safety, coroutines, Spring Boot uyumu, Ktor ile hafif API; Java ekosistemine tam erişim.</li>
            <li><strong>Dikkat:</strong> JVM tuning bilgisi gerekir; Gradle/build cache ayarlarını optimize et.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Dil Seçimi Testleri</h3>
          <p class="muted"><strong>Test 1:</strong> 50k eşzamanlı WebSocket + düşük latency. <em>Seç:</em> Node.js (event-loop) + TypeScript; CPU ağır iş varsa Go/Rust mikro servis ile offload.</p>
          <p class="muted"><strong>Test 2:</strong> Kurumsal B2B API, kapsamlı domain ve entegrasyonlar. <em>Seç:</em> Java/Spring Boot veya C#/.NET Core; güçlü DI, validation, observability ve tip güveni.</p>
        </div>
        <div class="card">
          <h3>Dil Seçimi Senaryoları (5’li)</h3>
          <p class="muted"><strong>Senaryo 1:</strong> 500 eşzamanlı kullanıcı, realtime bildirim/chat. <em>Seç:</em> Node.js/TypeScript; socket yükü için event-loop, ağır CPU işini worker’a ayır.</p>
          <p class="muted"><strong>Senaryo 2:</strong> 10k RPS public REST API + rate limit. <em>Seç:</em> Go (FastHTTP/Fiber) veya .NET minimal API; düşük latency, kolay rate limit middleware.</p>
          <p class="muted"><strong>Senaryo 3:</strong> AI/ML servis + API. <em>Seç:</em> Python (FastAPI) model servis için, önüne Go/Node gateway; ağır model işlemlerini ayrı worker’da tut.</p>
          <p class="muted"><strong>Senaryo 4:</strong> Kurumsal entegrasyon hub’ı (SOAP/REST/gRPC karışık). <em>Seç:</em> Java/Spring Boot veya C#/.NET; sağlam typing, async I/O, zengin entegrasyon kütüphaneleri.</p>
          <p class="muted"><strong>Senaryo 5:</strong> Edge/low-latency proxy veya WASM. <em>Seç:</em> Rust; hafif binary, güvenli bellek, yüksek throughput.</p>
        </div>
        <div class="card">
          <h3>Dil Geçişi Metodolojisi</h3>
          <p class="muted">1) Amaçları netleştir (performans, tip güvenliği, ekosistem). 2) Ortak kontrat (OpenAPI/proto) ve test seti oluştur. 3) Strangler pattern: yeni özellikleri yeni dilde yaz, eskiyi parça parça taşı. 4) Shared model/DTO’ları iki dilde de doğrulayan contract testleri çalıştır. 5) Gradual cutover: küçük trafiği yeni servise yönlendir, metrik/hatayı izle, kademeli artır. 6) Rollback planı hazır; feature flag ile kill-switch ekle.</p>
        </div>
      </div>
    </section>

    <section id="dil-senaryolari">
      <div class="section-head">
        <h2>Dil Seçimi Senaryoları</h2>
        <p class="section-desc">Duruma göre dil + mimari tercihini netleştirmek için detaylı örnekler.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Realtime Chat / Bildirim (500+ eşzamanlı)</h3>
          <p class="muted">WebSocket/SSE ile yüzlerce eşzamanlı bağlantı; düşük latency kritik. <strong>Seç:</strong> Node.js/TypeScript event-loop avantajı, Redis pub/sub ile fan-out; CPU ağır iş varsa Go/Rust worker’a offload. Backpressure ve rate limit middleware’leri ekle.</p>
        </div>
        <div class="card">
          <h3>10k RPS Public REST + Rate Limit</h3>
          <p class="muted">Yüksek RPS, hafif iş mantığı, hız odaklı API. <strong>Seç:</strong> Go (net/http/FastHTTP) veya .NET minimal API; düşük GC overhead, hızlı cold start. Token bucket rate limit, connection pool tuning, p95 hedefi için latency metriklerini zorunlu topla.</p>
        </div>
        <div class="card">
          <h3>AI/ML Servisi + Gateway</h3>
          <p class="muted">Model çağrısı Python (FastAPI) üzerinde; önünde API gateway. <strong>Seç:</strong> Go veya Node.js gateway (auth, rate limit, cache), model servisleri Python; ağır CPU/GPU işleri kuyruk/worker ile ayrıştır. gRPC veya REST seçimini client ekosistemine göre yap.</p>
        </div>
        <div class="card">
          <h3>Polyglot Persistence (SQL + NoSQL)</h3>
          <p class="muted">Transaction’lı çekirdek veri + esnek doküman/önbellek ihtiyacı. <strong>Seç:</strong> İşlemler için PostgreSQL/MySQL; oturum/cache/count için Redis; şema esnekliği gereken kısım için MongoDB. Dil: Go/Java/.NET tip güvenliği ve güçlü client kütüphaneleri ile; Node.js de uygun ama connection pool disiplinine dikkat.</p>
        </div>
        <div class="card">
          <h3>Edge/Proxy &amp; Çok Düşük Latency</h3>
          <p class="muted">CDN/edge worker veya L4/L7 proxy benzeri iş yükü. <strong>Seç:</strong> Rust (Axum/Actix) veya Go; hafif binary, düşük bellek, güvenli concurrency. TLS termination, rate limit ve basit rewrite için minimal middleware; cold start ve bellek ayak izini ölç.</p>
        </div>
      </div>
    </section>

    <section id="dil-modeli">
      <div class="section-head">
        <h2>Dil Çalışma Modeli</h2>
        <p class="section-desc">Derleme/çalıştırma hattı, VM/JIT/bytecode farkları ve nerede güçlü/zayıf olduklarını netleştirmek için.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Derleme/Çalışma Özeti</h3>
          <p class="muted">Derlenen diller (Go, Rust, C/C++) makine kodu üretir; start-up hızlı, runtime hafif. VM/bytecode dilleri (Java/Kotlin JVM, C#/.NET CLR, Elixir BEAM) bytecode üretir, JIT ve GC ile çalışır. Yorumlanan/JIT’lenen dinamik diller (JavaScript V8, Python, Ruby, PHP) bytecode/JIT ile hızlanır; başlangıç kolay, CPU-bound’da daha sınırlı. TypeScript önce JS’e transpile olur.</p>
          <p class="muted">Pipeline örneği: Kaynak kod → (opsiyonel transpile) → derleme/bytecode → (JIT) → makine kodu. GC’li dillerde heap temizliği latency’ye etki eder; ownership (Rust) veya manuel yönetim (C/C++) bu maliyeti runtime’dan alır.</p>
        </div>
      </div>
      <h3>Dil / Derleme Modeli Matrisi</h3>
      <table class="matrix">
        <thead>
          <tr>
            <th>Dil</th>
            <th>Derleme/Çalıştırma</th>
            <th>Runtime / Not</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>JavaScript (Node.js)</td>
            <td>JIT (V8), bytecode + optimizasyon; derleme yok.</td>
            <td>Event-loop, tek thread + worker; hızlı start, CPU-bound’da sınırlı.</td>
          </tr>
          <tr>
            <td>TypeScript</td>
            <td>Transpile → JavaScript, sonra V8 JIT.</td>
            <td>TS derlemesi build aşamasında; runtime JS gibi davranır.</td>
          </tr>
          <tr>
            <td>Go</td>
            <td>Statik derleme → tek binary (ELF/PE); linker dahildir.</td>
            <td>GC’li ama hafif runtime; hızlı start, kolay deploy.</td>
          </tr>
          <tr>
            <td>Rust</td>
            <td>LLVM ile statik derleme → makine kodu.</td>
            <td>GC yok, ownership modeli; yüksek performans ve güvenlik.</td>
          </tr>
          <tr>
            <td>Java / Kotlin</td>
            <td>Derleme → JVM bytecode (class/jar); JIT (HotSpot).</td>
            <td>Olgun GC (G1/ZGC), JIT ile uzun soluklu servislerde hızlanır; AOT seçeneği var.</td>
          </tr>
          <tr>
            <td>C# / .NET</td>
            <td>Derleme → IL; JIT (RyuJIT), Native AOT seçeneği.</td>
            <td>CLR GC, cross-platform; AOT ile cold start düşürülebilir.</td>
          </tr>
          <tr>
            <td>Python</td>
            <td>Bytecode (pyc) + yorumlayıcı; JIT yok (CPython).</td>
            <td>GIL nedeniyle CPU-bound sınırlı; C uzantıları veya PyPy/JIT alternatifleri hız kazandırabilir.</td>
          </tr>
          <tr>
            <td>PHP</td>
            <td>Yorumlanır + opcode cache (opcache).</td>
            <td>Hızlı iterasyon, FPM ile çalışır; CPU-bound sınırlı, opcache kritik.</td>
          </tr>
          <tr>
            <td>Ruby</td>
            <td>Yorumlanır (YARV bytecode).</td>
            <td>JIT deneysel; Rails ekosistemiyle üretken ama CPU-bound sınırlı.</td>
          </tr>
          <tr>
            <td>Elixir</td>
            <td>Derleme → BEAM bytecode.</td>
            <td>BEAM VM: hafif process, preemptive scheduler, güçlü fault-tolerance.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="veri-katmani">
      <div class="section-head">
        <h2>Veri Katmanı</h2>
        <p class="section-desc">Hangi DB nerede? Ek olarak mühendis seviyesi kavramların kısa özeti.</p>
      </div>
      <h3>Veritabanı Teknolojileri</h3>
      <div class="grid">
        <div class="card">
          <h3>PostgreSQL</h3>
          <ul>
            <li><strong>Altyapı:</strong> C ile yazıldı; güçlü planner/optimizer, MVCC.</li>
            <li><strong>Kullan/Güç:</strong> ACID, zengin index tipleri, JSONB, extension (PostGIS, pgvector); tek node’da doğru index/pool ile yüksek RPS.</li>
            <li><strong>Dikkat:</strong> Vacuum/ANALYZE disiplini, replication/partition tasarımı; büyük join’lerde planı gözle.</li>
          </ul>
        </div>
        <div class="card">
          <h3>MySQL / MariaDB</h3>
          <ul>
            <li><strong>Altyapı:</strong> C/C++ (InnoDB engine); yıllardır LAMP’ın omurgası.</li>
            <li><strong>Kullan/Güç:</strong> Basit CRUD/web, managed servis bolluğu; replikasyonla yatay okuma, uygun index ile yüksek RPS.</li>
            <li><strong>Dikkat:</strong> Engine seçimi (InnoDB), bazı gelişmiş SQL özellikleri kısıtlı; write scaling için sharding gerek.</li>
          </ul>
        </div>
        <div class="card">
          <h3>SQLite</h3>
          <ul>
            <li><strong>Altyapı:</strong> C, tek dosya veritabanı; embed çalışır.</li>
            <li><strong>Kullan/Güç:</strong> Edge, mobil, prototip, CLI; sıfır ops, tek binary. Hafif okuma yükünde binler RPS.</li>
            <li><strong>Dikkat:</strong> Sunucu değil; WAL modunda çok okuyucu + tek yazıcı destekler ama yüksek concurrency’ye uygun değil.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Redis</h3>
          <ul>
            <li><strong>Altyapı:</strong> C, tek thread + I/O multiplexing; in-memory.</li>
            <li><strong>Kullan/Güç:</strong> Cache, rate limit, queue/counter, pub/sub, stream; tek node’da yüz binlerce ops/s.</li>
            <li><strong>Dikkat:</strong> RAM maliyeti, persistence modu (AOF/RDB) ve eviction; shard/cluster ile ölçekle.</li>
          </ul>
        </div>
        <div class="card">
          <h3>MongoDB</h3>
          <ul>
            <li><strong>Altyapı:</strong> C++; doküman tabanlı, esnek şema.</li>
            <li><strong>Kullan/Güç:</strong> Hızlı iterasyon, nested veri, change stream; sharding ile yatay ölçek, on binlerce RPS.</li>
            <li><strong>Dikkat:</strong> Şema disiplini yoksa borç birikir; index ve write concern seçimi tutarlılığı belirler.</li>
          </ul>
        </div>
        <div class="card">
          <h3>SQL Server</h3>
          <ul>
            <li><strong>Altyapı:</strong> C/C++; olgun optimizer, Windows/Linux desteği.</li>
            <li><strong>Kullan/Güç:</strong> Kurumsal OLTP/OLAP, güçlü tooling (SSMS), columnstore index; iyi donanımda on binlerce TPS.</li>
            <li><strong>Dikkat:</strong> Lisans maliyeti, donanım ihtiyacı; Linux’ta bazı kısıtlar olabilir.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Oracle</h3>
          <ul>
            <li><strong>Altyapı:</strong> C/C++; kurumsal, zengin optimizer.</li>
            <li><strong>Kullan/Güç:</strong> Büyük finans/telekom yükleri, RAC ile yüksek erişilebilirlik; donanımda çok yüksek TPS.</li>
            <li><strong>Dikkat:</strong> Lisans ve operasyon maliyeti yüksek; yönetimi uzmanlık ister.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Cassandra</h3>
          <ul>
            <li><strong>Altyapı:</strong> Java; dağıtık column-family, masterless.</li>
            <li><strong>Kullan/Güç:</strong> Yüksek yazma hacmi, zaman serisi/olay log; lineer yatay ölçek, multi-DC replikasyon.</li>
            <li><strong>Dikkat:</strong> Join yok, sorgu kalıbı tablo tasarımını belirler; GC/tuning hassas, güçlü donanım ister.</li>
          </ul>
        </div>
        <div class="card">
          <h3>DynamoDB</h3>
          <ul>
            <li><strong>Altyapı:</strong> AWS managed, serverless key-value/document.</li>
            <li><strong>Kullan/Güç:</strong> Otomatik yatay ölçek, talebe göre kapasite; milyonlarca RCU/WCU’ya kadar elastik.</li>
            <li><strong>Dikkat:</strong> Erişim deseni tasarımı kritik; hot partition, TTL ve maliyet takibi şart.</li>
          </ul>
        </div>
      </div>

      <h3>Prosedür / Script Dilleri Eşlemesi</h3>
      <table class="matrix">
        <thead>
          <tr>
            <th>Veritabanı</th>
            <th>Prosedür / Script</th>
            <th>Kullanım / Not</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>PostgreSQL</td>
            <td>PL/pgSQL (ayrıca PL/Python, PL/v8)</td>
            <td>Fonksiyon/trigger mantığı; kompleks mantığı DB’ye yakın tutmak için. Transaction ve plan optimizasyonuna dikkat.</td>
          </tr>
          <tr>
            <td>SQL Server</td>
            <td>T-SQL Stored Procedure/Function, Agent Job</td>
            <td>OLTP/raporlama işlerinde prosedürler; job’lar ile zamanlanmış görevler. Parametre sniffing ve plan cache’e dikkat.</td>
          </tr>
          <tr>
            <td>MySQL / MariaDB</td>
            <td>Stored Procedure/Function, Event Scheduler</td>
            <td>Basit mantıklar için SP; ağır işlerde app katmanını tercih et. Event Scheduler ile zamanlanmış işler yapılabilir.</td>
          </tr>
          <tr>
            <td>Oracle</td>
            <td>PL/SQL</td>
            <td>Gelişmiş prosedür/trigger desteği; paket yapısı zengin. Operasyon ve lisans maliyetine dikkat.</td>
          </tr>
          <tr>
            <td>SQLite</td>
            <td>Yerleşik SQL + trigger (stored proc yok)</td>
            <td>Basit trigger’lar ve pragmalar; karmaşık mantık uygulama katmanında olmalı. Embed senaryolara uygun.</td>
          </tr>
          <tr>
            <td>MongoDB</td>
            <td>Aggregation Pipeline, sınırlı server-side JS</td>
            <td>İş mantığı pipeline’da; trigger için change streams kullanılır. Ağır mantığı uygulama/worker tarafında tut.</td>
          </tr>
          <tr>
            <td>Redis</td>
            <td>Lua Script</td>
            <td>Atomik, tek round-trip işlemler için. Uzun süren script event loop’u bloklar; kısa tut.</td>
          </tr>
          <tr>
            <td>Cassandra</td>
            <td>UDF/UDA (Java) sınırlı</td>
            <td>Genelde önerilmez; veri modeli sorguya göre tasarlanır. İş mantığını uygulamaya koymak daha güvenli.</td>
          </tr>
          <tr>
            <td>DynamoDB</td>
            <td>Trigger = Lambda (Streams)</td>
            <td>Doğrudan stored proc yok; Streams + Lambda ile değişiklik sonrası işlem yapılır.</td>
          </tr>
        </tbody>
      </table>

      <h3>Veri Kavramları</h3>
      <div class="grid">
        <div class="card">
          <h3>Relational vs NoSQL mantığı</h3>
          <p class="muted">Relational modeller katı şema ve güçlü join ile ACID odaklıdır; NoSQL esneklik ve yatay ölçek sunar. Polyglot yaklaşımda her veri tipi için uygun model seçilir.</p>
        </div>
        <div class="card">
          <h3>Primary key, foreign key</h3>
          <p class="muted">PK benzersiz kimliktir, genelde indexlidir; FK referential integrity sağlar ve CASCADE/RESTRICT gibi kuralları uygular.</p>
        </div>
        <div class="card">
          <h3>Index tipleri</h3>
          <p class="muted">Index okuma hızını artırır, yazma maliyetini yükseltir. B-Tree aralık ve sıralı sorgularda, Hash eşitlik aramalarında etkilidir; kolon seçimi ve kardinalite kritiktir.</p>
        </div>
        <div class="card">
          <h3>Query plan / EXPLAIN</h3>
          <p class="muted">Optimizer’ın sorguyu nasıl çalıştıracağını gösterir (scan, join sırası, maliyet). EXPLAIN ANALYZE ile tahmin/gerçek satır farkı optimizasyon ipucu verir.</p>
        </div>
        <div class="card">
          <h3>ACID</h3>
          <p class="muted">Atomicity, Consistency, Isolation, Durability: transaction’ın bütünlük ve kalıcılık garantisi. Isolation seviyesi performans/tutarlılık dengesini belirler.</p>
        </div>
        <div class="card">
          <h3>Transactions</h3>
          <p class="muted">Mantıksal işlem kümesini commit/rollback ile yönetir. Yanlış sınırlandırma kilitlenme ve contention yaratır; kısa tut, doğru isolation seç.</p>
        </div>
        <div class="card">
          <h3>Joins</h3>
          <p class="muted">Inner eşleşenleri, left solun tamamını getirir; right simetriğidir. Performans join kolonlarındaki index ve plan sırası ile belirlenir.</p>
        </div>
        <div class="card">
          <h3>N+1 problemi</h3>
          <p class="muted">Ana sorgu + her kayıt için ekstra sorgu patlaması. Eager loading, join veya toplu fetch ile çöz; ORM lazy loading’ine dikkat.</p>
        </div>
        <div class="card">
          <h3>Connection pool</h3>
          <p class="muted">Bağlantıları yeniden kullanarak aç/kapat maliyetini düşürür. Pool boyutu küçükten başla; idle/lifetime sınırları ve health check ile sızıntıyı önle.</p>
        </div>
        <div class="card">
          <h3>Yönetim araçları &amp; disiplin</h3>
          <p class="muted">Günlük yönetim/teşhis: PostgreSQL için psql/pgAdmin/ps_top, SQL Server için SSMS/Azure Data Studio, MySQL için Workbench, Mongo için Compass, Redis için redis-cli, Dynamo için Console/CLI. Şema değişikliği GUI’de değil migration/DDL dosyası ve code review ile yapılmalı; prod’da tıklayarak değişiklik yapma. Trigger/func/acl gibi nesneleri de migration’larla versiyonla.</p>
        </div>
        <div class="card">
          <h3>DB Seçimi Testleri</h3>
          <p class="muted"><strong>Test 1:</strong> Finansal OLTP, güçlü transaction + raporlama. <em>Seç:</em> PostgreSQL (varsayılan) veya SQL Server/Oracle; ACID, index çeşitliliği, karmaşık sorgu desteği.</p>
          <p class="muted"><strong>Test 2:</strong> Yüksek hacimli telemetry/event akışı, yazma ağırlıklı, basit sorgu. <em>Seç:</em> Cassandra veya DynamoDB; yatay ölçek, append-heavy iş yükü, predictable throughput.</p>
          <p class="muted"><strong>Test 3:</strong> OLAP/raporlama, büyük veri taraması. <em>Seç:</em> Columnar (cloud warehouse) veya PostgreSQL + columnstore extension; ETL/batch dostu.</p>
          <p class="muted"><strong>Test 4:</strong> Graph ilişkiler (öneri, sosyal). <em>Seç:</em> Neo4j/ArangoDB; graph sorgu ve traversal için optimize.</p>
        </div>
      </div>
    </section>

    <section id="servis-akisi">
      <div class="section-head">
        <h2>Servis Akışı</h2>
        <p class="section-desc">İstekten cevaba pipeline; mimari kararları burada toparla.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Request–Response Cycle</h3>
          <p class="muted">Client → reverse proxy → backend → DB/cache/queue → response. Her katmanın gecikmesi trace ile ölçülmeli.</p>
        </div>
        <div class="card">
          <h3>Routing</h3>
          <p class="muted">URL+method → handler. Versiyonlama ve auth kuralları ayrı; prefix-matching ve statik tablo performans sağlar.</p>
        </div>
        <div class="card">
          <h3>Middleware</h3>
          <p class="muted">Auth, logging, rate limit, error handler, body parser. Sıralama kritiktir; logging/error en dışta olmalı.</p>
        </div>
        <div class="card">
          <h3>Controller / Handler</h3>
          <p class="muted">İsteği alır, doğrular, iş mantığını çalıştırır, yanıtı hazırlar. İnce controller + service katmanı + DTO okunabilirlik getirir.</p>
        </div>
        <div class="card">
          <h3>API türleri</h3>
          <p class="muted">REST (genel), GraphQL (esnek client), gRPC (contract/hız), WebSocket (realtime). Seçimi client ihtiyacına göre yap.</p>
        </div>
        <div class="card">
          <h3>Monolith vs Microservice</h3>
          <p class="muted">Monolith hızla başlar, transaction sınırları basit. Microservice domain ayırır, bağımsız ölçeklenir; dağıtık karmaşıklık ve gözlemleme yükü getirir.</p>
        </div>
        <div class="card">
          <h3>Scaling</h3>
          <p class="muted">Vertical: CPU/RAM artır. Horizontal: instance çoğalt + load balancer; stateless tasarım veya sticky session/sharding gerektirir.</p>
        </div>
        <div class="card">
          <h3>Caching</h3>
          <p class="muted">Sıcak veriyi RAM’de tutarak latency ve DB yükünü düşürür. Key tasarımı, TTL ve invalidation stratejisi hatasız çalışmanın temeli.</p>
        </div>
        <div class="card">
          <h3>Environment &amp; Config</h3>
          <p class="muted">Ortam bazlı ayarlar (.env, secret store); config-in-code yerine environment-driven. Prod/stage/dev ayrımı ve gizli bilgilerin korunması şart.</p>
        </div>
      </div>
    </section>

    <section id="dagitik-dayaniklilik">
      <div class="section-head">
        <h2>Dağıtık &amp; Dayanıklılık</h2>
        <p class="section-desc">Yük, hata ve network dalgalanmalarına karşı sağlam kalma araçları.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Cache mantığı ve invalidation</h3>
          <p class="muted">Hit oranı performansı belirler. Invalidation: TTL, yazma sonrası aktif silme, versiyonlama/namespace. Yanlış invalidation tutarsız veri demek.</p>
        </div>
        <div class="card">
          <h3>Redis nedir?</h3>
          <p class="muted">RAM üstü key-value; TTL, pub/sub, stream, Lua, atomic counter. Cache, rate limit, queue, oturum için kullanılır; eviction/persistence ayarını yap.</p>
        </div>
        <div class="card">
          <h3>Message Queue</h3>
          <p class="muted">Producer/consumer’ı ayırır. RabbitMQ queue/ack, Kafka append-only log + yüksek throughput. Retry, dead-letter ve backpressure yük dalgasını emer.</p>
        </div>
        <div class="card">
          <h3>Rate limiting</h3>
          <p class="muted">Belirli pencerede istek sayısını sınırlar; token bucket/leaky bucket yaygın. Dağıtık sayaç için merkezi veya shard’lı yaklaşım gerekir.</p>
        </div>
        <div class="card">
          <h3>Idempotency &amp; Retry</h3>
          <p class="muted">Idempotency key, deterministik state ve deduplikasyon kritik. Retry’de exponential backoff + jitter kullan; yoksa thundering herd olur.</p>
        </div>
        <div class="card">
          <h3>Load balancing</h3>
          <p class="muted">Algoritmalar: round-robin, least-connections, IP-hash; health check ile bozuk node’u trafikten çek. L4 (TCP) ve L7 (HTTP) LB; L7 path/host bazlı yönlendirme sağlar. Sticky session gerekiyorsa session store veya consistent hash kullan.</p>
        </div>
        <div class="card">
          <h3>Reverse proxy</h3>
          <p class="muted">Nginx/Traefik tek giriş, SSL termination, gzip, header rewrite ve routing. Mikroserviste servis keşfi entegrasyonu kritik.</p>
        </div>
        <div class="card">
          <h3>CDN</h3>
          <p class="muted">Statik ve cache’lenebilir içeriği edge’e taşır; en yakın noktadan servis ederek latency ve origin trafiğini düşürür. Cache key/TTL/invalidation kuralı net olmalı.</p>
        </div>
        <div class="card">
          <h3>Circuit breaker</h3>
          <p class="muted">Hatalı/yavaş servise çağrıları kısa devre eder; closed/open/half-open durumları. Fallback veya degrade yanıt zincirleme çöküşü önler.</p>
        </div>
        <div class="card">
          <h3>Health check &amp; probes</h3>
          <p class="muted">Liveness kilitlenmeyi, readiness trafiğe hazır olmayı ölçer. Başarısızsa yeniden başlatma veya trafikten çekme otomatik yapılır.</p>
        </div>
      </div>
    </section>

    <section id="operasyon">
      <div class="section-head">
        <h2>Operasyon</h2>
        <p class="section-desc">Gözlemleme, kapasite ve çalışma anı disiplini.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Logging ve Observability</h3>
          <p class="muted">Structured JSON + seviye (INFO/ERROR/WARN/DEBUG) + trace/correlation ID zorunlu. Logları merkezileştir (ELK/Opensearch, Loki+Grafana, bulut log). PII’yi maskele, sampling ve rotation ile hacmi kontrol et; yüksek gürültüde drop yerine sampling tercih et.</p>
          <p class="muted"><strong>Tracing/Metrics:</strong> OpenTelemetry ile trace/span, RED/USE metrikleri (rate, errors, duration / utilization, saturation, errors) ve alert tanımları birlikte tutulmalı.</p>
        </div>
        <div class="card">
          <h3>Concurrency seçimi</h3>
          <p class="muted">I/O-bound için event-loop/async (Node, async Python/.NET), CPU-bound için goroutine/thread pool. Oversubscription’tan kaçın; uzun işleri kuyruk/worker’a ayır.</p>
        </div>
        <div class="card">
          <h3>Veritabanı kapasitesi</h3>
          <p class="muted">DB CPU/IOPS/lock ile sınırlı. Pool boyutunu küçük başlat, wait time’a göre ayarla; N+1 ve tam tablo taramalarını azalt; index+cache ile yük düşür.</p>
        </div>
        <div class="card">
          <h3>SLO/SLA &amp; Alerting</h3>
          <p class="muted">Hedef metrikler: p95 latency, hata oranı, availability; bunlara göre SLO yaz ve error budget’a alarm bağla. Semptom bazlı uyarı (5xx artışı, queue derinliği, CPU saturasyon) aksiyon almayı hızlandırır.</p>
        </div>
        <div class="card">
          <h3>Runbook &amp; Postmortem</h3>
          <p class="muted">Her kritik alarm için runbook: 5xx artışı → log/trace, son deploy/migration kontrolü, rollback kriteri; queue şişmesi → tüketici sayısı, DLQ, backpressure; DB connection spike → pool sınırları, uzun sorgular, index eksikleri. Postmortem’de kök neden, aksiyon ve sahiplik tanımla; tekrarı önlemek için kalıcı iyileştirme ekle.</p>
        </div>
      </div>
    </section>

    <section id="test-yayin">
      <div class="section-head">
        <h2>Test ve Yayın</h2>
        <p class="section-desc">Geri alma yolu açık, kırılmadan yayınlama rutini.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Test stratejisi</h3>
          <p class="muted">Unit (domain), integration (DB/cache/queue), contract/consumer-driven (servis uyumu), E2E smoke (deploy sonrası), load/perf (prod’a yakın ortam) sırasını oturt.</p>
        </div>
        <div class="card">
          <h3>CI/CD ve release</h3>
          <p class="muted">Build → test → statik analiz/security → paket/deploy pipeline’ı. Blue/green veya canary kademeli rollout; feature flag ile kısmi aç/kapa. Rollback ve migration sırası önceden tanımlı olsun.</p>
        </div>
        <div class="card">
          <h3>Şema/migration disiplini</h3>
          <p class="muted">Önce ekle (kolon/index), kodu uyumlu deploy et, sonra temizle. Uzun migration’ları batch/backfill ile yap; büyük tabloda uzun lock’tan kaçın.</p>
        </div>
        <div class="card">
          <h3>API kontrat ve dokümantasyon</h3>
          <p class="muted">REST için OpenAPI/Swagger, gRPC için proto tek kaynak olmalı; versiyonlama/breaking change politikası net. Contract/schema linter’ları pipeline’a ekle; örnek istek-yanıt/hata kodları entegrasyonu hızlandırır.</p>
        </div>
        <div class="card">
          <h3>Rollout &amp; Flag Akışı</h3>
          <p class="muted">Canary: küçük yüzde ile aç → metrik/alert izle → kademeli artır → sorun varsa rollback. Feature flag: kodu ship et, flag ile kısmi aç; kill-switch hazır tut.</p>
        </div>
        <div class="card">
          <h3>Büyük migration/backfill</h3>
          <p class="muted">Yeni kolon/şema ekle, kodu uyumlu deploy et, background backfill ile veriyi doldur, trafik yeni alanı kullanınca eskisini kaldır. Batch boyutlarını küçük tut, lock sürelerini izle.</p>
        </div>
      </div>
    </section>

    <section id="guvenlik">
      <div class="section-head">
        <h2>Güvenlik</h2>
        <p class="section-desc">Kimlik, yetki, şifreleme ve tarayıcı güvenliği özet.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Authentication vs Authorization</h3>
          <p class="muted">Authentication kimliği doğrular; authorization yetkiyi belirler. Doğrulama olmadan yetki verilmez; policy’ler role/attribute tabanlı tanımlanır.</p>
        </div>
        <div class="card">
          <h3>JWT</h3>
          <p class="muted">Header.payload.signature self-contained token. Exp/iat/nbf zorunlu; imza bütünlüğü sağlar; revocation için kısa TTL veya blacklist gerekir.</p>
        </div>
        <div class="card">
          <h3>OAuth2 / OpenID Connect</h3>
          <p class="muted">OAuth2 yetki delegasyonu; OIDC kimlik katmanı (ID Token). Authorization server access token üretir, resource server scope’a göre doğrular. PKCE ve state CSRF/code çalınmasını önler.</p>
        </div>
        <div class="card">
          <h3>HTTPS &amp; TLS</h3>
          <p class="muted">TLS 1.2/1.3, güçlü cipher, HSTS; sertifika zinciri/OCSP/CRL ve SNI uyumu önemli. Şifreleme gizlilik, bütünlük ve kimlik doğrulama sağlar.</p>
        </div>
        <div class="card">
          <h3>Rate limiting &amp; güvenlik</h3>
          <p class="muted">Brute force, credential stuffing, DDoS’a karşı ilk katman. IP/kullanıcı/token bazlı kotalar; 429 + retry-after ile geri bildirim.</p>
        </div>
        <div class="card">
          <h3>CSRF / XSS</h3>
          <p class="muted">CSRF: same-site cookie/CSRF token/SameSite=Lax-Strict. XSS: output encoding, CSP, input validation; reflected/stored/DOM varyantlarına dikkat.</p>
        </div>
        <div class="card">
          <h3>Password hashing</h3>
          <p class="muted">bcrypt/Argon2 gibi yavaş, salted algoritmalar. Cost/memory/parallelism ayarlarını güncel tut; hızlı hash’ler (SHA-256) parola için uygun değildir.</p>
        </div>
      </div>
    </section>

    <section id="teknik-notlar">
      <div class="section-head">
        <h2>Teknik Notlar</h2>
        <p class="section-desc">Dil/runtime davranışı ve performans kavramlarını derinleştirmek için.</p>
      </div>
      <div class="grid">
        <div class="card">
          <h3>CPU-bound</h3>
          <p class="muted">Süre CPU hesaplarında geçer; çekirdek sayısı ve algoritma karmaşıklığı belirleyici. Paralelleştirme yoksa tek çekirdek sınırıdır; profiling + hot path optimizasyonu gerekir.</p>
        </div>
        <div class="card">
          <h3>I/O-bound</h3>
          <p class="muted">Zamanın çoğu dış kaynağı bekler. Async/event-driven modeller beklemeyi overlap eder; pooling, batching, caching ve backpressure throughput’u yükseltir.</p>
        </div>
        <div class="card">
          <h3>CPU kullanımı (thread modeli)</h3>
          <p class="muted">C#/Java OS thread + pool; Node event loop + worker threads; Go M:N goroutine scheduler. Scheduler ve work-stealing çekirdek doluluğunu belirler.</p>
        </div>
        <div class="card">
          <h3>RAM (Heap/Stack/GC)</h3>
          <p class="muted">Stack hızlı ve LIFO; heap dinamik ömürlü nesneler için. GC duraklamaları latency’yi etkiler; Rust/C++ ownership, arena/stack allocation ile heap baskısını azaltır.</p>
        </div>
        <div class="card">
          <h3>Concurrency</h3>
          <p class="muted">Birden fazla iş biriminin ilerlemesi; race/deadlock/starvation riskleri lock/mutex/semaphore/mesaj geçirme ile yönetilir. Immutable veri ve izolasyon contention’ı azaltır.</p>
        </div>
        <div class="card">
          <h3>Parallelism</h3>
          <p class="muted">Gerçek eşzamanlı çalışma; CPU-bound işleri hızlandırır. Veri bağımlılıkları ve kilitler kazancı yiyebilir; work-stealing ve load balancing önemlidir.</p>
        </div>
        <div class="card">
          <h3>Blocking vs Non-blocking</h3>
          <p class="muted">Blocking thread bekletir; havuz dar ise throughput düşer. Non-blocking I/O tamamlanınca callback/promise ile devam eder; backpressure olmadan yine boğulur.</p>
        </div>
        <div class="card">
          <h3>Throughput vs Latency</h3>
          <p class="muted">Throughput (RPS/TPS) ve latency (p50/p95/p99) gerilimlidir. Batching/queueing throughput’u, düşük queue derinliği ve sıcak cache latency’yi korur.</p>
        </div>
        <div class="card">
          <h3>Synchronous vs Asynchronous</h3>
          <p class="muted">Sync basit akış; async bekleyen I/O’yu daha az thread ile yönetir. CPU-bound işlerde async tek başına yetmez; paralel yürütme veya offload gerekir.</p>
        </div>
        <div class="card">
          <h3>Event Loop (Node.js)</h3>
          <p class="muted">Tek thread’li loop; I/O OS’ye offload, tamamlanınca micro/macro task kuyruğu çalışır. CPU-bound işleri worker_threads’e taşı, loop’u tıkama.</p>
        </div>
        <div class="card">
          <h3>Goroutine Scheduler (Go)</h3>
          <p class="muted">M:N model; work-stealing ile goroutine’leri az sayıda OS threadine dağıtır. Syscall/bloklama park eder; GOMAXPROCS aynı anda çalışan thread sayısını sınırlar.</p>
        </div>
        <div class="card">
          <h3>Thread Pool (C#, Java)</h3>
          <p class="muted">Yeniden kullanılabilir OS thread’leri; minimum/maksimum, kuyruk ve work-stealing stratejileri vardır. Async/await/CompletableFuture bloklamayı azaltır; oversubscription context switch yükü yaratır.</p>
        </div>
      </div>
    </section>

    <section id="kapsam-disi">
      <h2>Kapsam Dışı</h2>
      <p class="muted">Boğucu detaylar burada yok:</p>
      <ul>
        <li>Garbage collector derinliği, thread pool mikro mimarisi</li>
        <li>JIT/AOT farkı, memory modeli, assembly-level konular</li>
        <li>Linux kernel scheduling, K8s deep dive</li>
        <li>Reactive programming detayları, CAP theorem teknik analizi</li>
      </ul>
    </section>

    <section id="not">
      <h2>Not</h2>
      <div class="callout">
        Swift, Objective-C gibi diller backend dünyasının ana konseptine girmiyor; dokümana eklenmedi.
      </div>
    </section>
    </main>
  </div>
  <a class="to-top" href="#top" aria-label="Başa dön">Yukarı ↑</a>
</body>
</html>
