<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Backend ve Programlama Dilleri - Temel Kavramlar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
      max-width: 900px;
      margin-inline: auto;
      background: #f5f5f5;
    }
    h1, h2, h3 {
      margin-top: 1.8rem;
    }
    code {
      background: #eee;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.95em;
    }
    .note {
      background: #fff8e1;
      border-left: 4px solid #ffb300;
      padding: 0.75rem 1rem;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .tag {
      display: inline-block;
      padding: 0.1rem 0.6rem;
      border-radius: 999px;
      background: #e0e0e0;
      font-size: 0.8rem;
      margin-right: 0.35rem;
      margin-bottom: 0.35rem;
    }
    ul {
      padding-left: 1.2rem;
    }
  </style>
</head>
<body>

  <h1>Backend & Programlama Dilleri - Temel Kavramlar Notları</h1>

  <div class="note">
    Bu doküman; Go, Node.js, .NET, Rust gibi diller arasında seçim yaparken 
    temel kavramları anlamak için hazırlanmış bir özet. 
    <br>
    İleride Codex / başka bir araç ile genişletmek için başlık odaklı yazıldı.
  </div>

  <h2>0. Genel Kavram Haritası</h2>
  <p>Bu dokümanda sık geçen ana kavramlar:</p>
  <p>
    <span class="tag">Programming Language</span>
    <span class="tag">Runtime</span>
    <span class="tag">Framework</span>
    <span class="tag">Library</span>
    <span class="tag">I/O-bound</span>
    <span class="tag">CPU-bound</span>
    <span class="tag">Concurrency</span>
    <span class="tag">Parallelism</span>
    <span class="tag">Thread</span>
    <span class="tag">Event Loop</span>
    <span class="tag">Goroutine</span>
    <span class="tag">Async / Await</span>
  </p>

  <h2>1. Programlama Dili Nedir? (Programming Language)</h2>
  <p>
    <strong>Programlama dili</strong>, bilgisayara ne yapacağını tarif etmek için
    kullandığımız kurallı (syntax + semantics) yapıdır.
  </p>

  <h3>1.1. Dil – Runtime – Framework farkı</h3>
  <ul>
    <li>
      <strong>Dil (Language)</strong>: 
      C#, Go, Java, JavaScript, Rust, Python, vb.
      <br>
      Kod yazdığın şey. Kurallar, tip sistemi, sözdizimi, kontrol yapıları.
    </li>
    <li>
      <strong>Runtime</strong>:
      Dilin çalıştığı ortam / sanal makine / engine.
      <ul>
        <li>.NET → <code>CLR</code></li>
        <li>Java → <code>JVM</code></li>
        <li>Node.js → <code>V8 + event loop</code></li>
        <li>Go → kendi runtime’ı (scheduler, GC, goroutine yönetimi)</li>
      </ul>
    </li>
    <li>
      <strong>Framework</strong>:
      Hazır iskelet + pattern + kütüphane seti.
      <ul>
        <li>.NET: ASP.NET Core, Minimal API, MVC</li>
        <li>Node.js: Express, NestJS, Fastify</li>
        <li>Go: Fiber, Gin, Echo</li>
        <li>Java: Spring Boot, Micronaut</li>
      </ul>
    </li>
    <li>
      <strong>Library (Kütüphane)</strong>:
      Framework kadar büyük olmayan, belirli işi çözen paket.
      Örn: JWT kütüphanesi, logging kütüphanesi, HTTP client, vb.
    </li>
  </ul>

  <h3>1.2. Derlenen vs yorumlanan (Compile vs Interpret)</h3>
  <ul>
    <li>
      <strong>Derlenen diller</strong>: 
      Go, Rust, C/C++, çoğu zaman C# ve Java da bu grupta (JIT/AOT).
      <br>
      Kod → derleyici → binary / bytecode → runtime’da çalışır.
    </li>
    <li>
      <strong>Yorumlanan diller</strong>: 
      JavaScript (tarayıcı), Python, Ruby vb.  
      Genelde satır satır veya bytecode seviyesinde yorumlanır.
    </li>
  </ul>

  <h3>1.3. Statik tip, dinamik tip (Static vs Dynamic Typing)</h3>
  <ul>
    <li><strong>Statik tipli</strong>: C#, Go, Rust, Java, Kotlin</li>
    <li><strong>Dinamik tipli</strong>: JavaScript, Python, Ruby</li>
    <li><strong>TypeScript</strong>: JavaScript’e statik tip katmanı</li>
  </ul>

  <div class="note">
    Burayı genişletme fikri: 
    “Niye statik tip tercih edilir?”, “Prod ortamda tip güvenliği neden önemli?”
  </div>

  <h2>2. Backend’te İş Yükü Tipleri: I/O-bound vs CPU-bound</h2>

  <h3>2.1. I/O-bound nedir?</h3>
  <p>
    Programın çoğu zamanı CPU’da işlem yaparak değil, 
    <strong>I/O (Input/Output)</strong> bekleyerek geçiyorsa,
    bu iş yüküne <strong>I/O-bound</strong> denir.
  </p>
  <ul>
    <li>Veritabanı sorgusu beklemek</li>
    <li>Dosya okuma/yazma</li>
    <li>HTTP isteği atıp cevap beklemek</li>
    <li>Mesaj kuyruğundan (RabbitMQ, Kafka) mesaj beklemek</li>
  </ul>

  <h3>2.2. CPU-bound nedir?</h3>
  <p>
    Programın çoğu zamanı doğrudan CPU üzerinde ağır hesap yaparak geçiyorsa,
    bu iş yüküne <strong>CPU-bound</strong> denir.
  </p>
  <ul>
    <li>Büyük döngüler (milyonlarca iterasyon)</li>
    <li>Kriptografi, şifreleme, hashing</li>
    <li>Görüntü / video işleme</li>
    <li>Büyük veriler üzerinde yoğun matematiksel işlem</li>
  </ul>

  <div class="note">
    Önemli nokta:  
    Node.js → I/O-bound için ideal, CPU-bound için problemli.  
    Go / .NET / Java / Rust → CPU + I/O karışık iş yüklerinde daha dengeli.
  </div>

  <h2>3. Concurrency ve Parallelism</h2>

  <h3>3.1. Concurrency (Eşzamanlılık)</h3>
  <p>
    <strong>Concurrency</strong> = Aynı anda birden fazla işin 
    ilerliyor gibi yönetilmesi.  
    Tek CPU çekirdeğinde bile, işler arasında hızlı geçiş yaparak
    “aynı anda” çalışıyor hissi verir.
  </p>

  <h3>3.2. Parallelism (Paralellik)</h3>
  <p>
    <strong>Parallelism</strong> = Gerçekten aynı anda birden fazla çekirdekte 
    gerçekten fiziksel olarak aynı anda işlem yapılması.
  </p>

  <h3>3.3. Thread Nedir?</h3>
  <p>
    <strong>Thread</strong>:
    Bir işlem (process) içinde çalışan hafif yürütme birimidir.
  </p>
  <ul>
    <li>Java / .NET → Thread pool, task, async-await, vb.</li>
    <li>Go → Goroutines (thread’lerden bile daha hafif logical unit)</li>
    <li>Rust → OS thread + async runtime (tokio vs.)</li>
  </ul>

  <h3>3.4. Event Loop Nedir? (Node.js Modeli)</h3>
  <p>
    <strong>Event loop</strong>, Node.js gibi ortamlarda kullanılan modeldir:
  </p>
  <ul>
    <li>Tek bir ana thread üzerinde çalışır (single-threaded).</li>
    <li>
      I/O işleri (disk, ağ, DB) mümkün olduğu kadar OS’in async mekanizmalarına
      offload edilir.
    </li>
    <li>
      İşler küçük callback / promise / async fonksiyonlar olarak kuyruğa alınır,
      event loop bu kuyruğu sürekli döner.
    </li>
  </ul>
  <p>
    Sorun: CPU-bound bir iş event loop’u bloke ederse, 
    sistemdeki diğer istekler beklemeye başlar.
  </p>

  <h3>3.5. Go’daki Goroutine Modeli</h3>
  <p>
    Go, concurrency için <strong>goroutine</strong> ve 
    <strong>scheduler</strong> kullanır:
  </p>
  <ul>
    <li>Goroutine = çok hafif thread benzeri iş birimi</li>
    <li>OS thread’lerinin üzerinde çalışırlar</li>
    <li>Go runtime, goroutine’leri thread’lere dağıtır</li>
    <li>Yüzbinlerce goroutine ölçeklenebilir</li>
  </ul>

  <h3>3.6. .NET / Java Concurrency Modeli</h3>
  <p>
    .NET ve Java tipik olarak şu kavramlarla çalışır:</p>
  <ul>
    <li>Thread pool</li>
    <li>Task (C#), Future/CompletableFuture (Java)</li>
    <li>async/await (C#), reactive pattern’ler (Project Reactor vb.)</li>
  </ul>

  <div class="note">
    Genişletme fikri:  
    “Thread pool nasıl çalışır?”  
    “Async/await alt tarafta ne yapıyor?”  
  </div>

  <h2>4. API, Web Backend ve Request Lifecycle</h2>

  <h3>4.1. API (Application Programming Interface)</h3>
  <p>
    <strong>API</strong> = Uygulamaların birbiri ile konuştuğu sözleşmedir.  
    Backend tarafında en yaygın format: HTTP üzerinden REST / JSON veya gRPC.
  </p>

  <h3>4.2. Tipik Web API Akışı</h3>
  <ol>
    <li>Client (web / mobil / başka servis) HTTP isteği gönderir</li>
    <li>Reverse proxy / load balancer isteği ilgili backend instance’a iletir</li>
    <li>Backend framework (ASP.NET Core, Express, Fiber vb.) isteği route eder</li>
    <li>Controller / handler iş mantığını çalıştırır</li>
    <li>DB / cache / queue çağrıları yapılır (I/O-bound işler)</li>
    <li>Sonuç JSON / XML / Protobuf vb. formatta client’a döner</li>
  </ol>

  <h3>4.3. Framework’lerin Temel Rolü</h3>
  <ul>
    <li>Routing (URL → handler eşleştirme)</li>
    <li>Middleware pipeline (auth, logging, rate limiting vb.)</li>
    <li>Model binding / validation</li>
    <li>Response serialization (JSON vs.)</li>
    <li>DI (Dependency Injection) ve konfigurasyon yönetimi</li>
  </ul>

  <h2>5. Dillerin ve Stack’lerin Konumlanması</h2>

  <h3>5.1. Node.js (JavaScript / TypeScript)</h3>
  <ul>
    <li>Model: Single-thread + event loop</li>
    <li>Güçlü olduğu yer: I/O-heavy web API, realtime (WebSocket)</li>
    <li>Zayıf olduğu yer: CPU-bound ağır işlemler</li>
    <li>Avantaj: JS/TS ile hızlı ürün geliştirme, büyük ekosistem</li>
  </ul>

  <h3>5.2. Go (Golang)</h3>
  <ul>
    <li>Model: Goroutine + scheduler (yüksek concurrency)</li>
    <li>Güçlü olduğu yer: yüksek trafikli servisler, cloud-native, DevOps tooling</li>
    <li>Avantaj: Tek binary, basit dil, hafif runtime</li>
    <li>Framework örnekleri: Fiber, Gin, Echo</li>
  </ul>

  <h3>5.3. .NET (C# / ASP.NET Core)</h3>
  <ul>
    <li>Model: Multi-thread, thread pool, async/await</li>
    <li>Güçlü olduğu yer: kurumsal projeler, büyük backend’ler, microservice + monolith</li>
    <li>Avantaj: Zengin framework, güçlü tooling, enterprise desteği</li>
  </ul>

  <h3>5.4. Rust</h3>
  <ul>
    <li>Model: Zero-cost abstraction, ownership, borrow checker</li>
    <li>Güçlü olduğu yer: high-performance server, sistem programlama</li>
    <li>Avantaj: C performansı + memory safety</li>
    <li>Eksisi: Öğrenme eğrisi dik</li>
  </ul>

  <h2>6. Dil/Stack Seçiminde Kriterler</h2>
  <p>Backend teknolojisi seçerken bakılacak temel eksenler:</p>
  <ul>
    <li><strong>İş yükü tipi</strong>: I/O-heavy mi, CPU-heavy mi?</li>
    <li><strong>Ölçek</strong>: Kaç request / saniye, nasıl büyüyecek?</li>
    <li><strong>Ekip yetkinliği</strong>: Kim neyi biliyor?</li>
    <li><strong>Ekosistem ihtiyacı</strong>: AI, data, web, mobile vs.</li>
    <li><strong>Bakım maliyeti</strong>: 3 yıl sonra da yönetilebilir mi?</li>
  </ul>

  <h3>6.1. Tipik Senaryo Özetleri</h3>
  <ul>
    <li>
      <strong>Hızlı ürün çıkarmak (SaaS, dashboard)</strong>:
      Node.js + TypeScript + modern frontend (Next.js vb.)
    </li>
    <li>
      <strong>Kurumsal, uzun ömürlü backend</strong>:
      C# / ASP.NET Core veya Java / Spring Boot
    </li>
    <li>
      <strong>Cloud-native, yüksek concurrency servisleri</strong>:
      Go (Golang) + container + K8s
    </li>
    <li>
      <strong>Aşırı performans kritik, low-level işler</strong>:
      Rust
    </li>
  </ul>

  <h2>7. Genişletme İçin Boş Alanlar</h2>
  <p>
    Bu başlıklar, daha sonra Codex veya başka bir araç kullanarak
    detay açmak için bırakıldı.
  </p>

  <h3>7.1. Önerilen Alt Başlıklar</h3>
  <ul>
    <li>Thread pool nasıl çalışır? (C#, Java)</li>
    <li>Garbage Collector nedir, dil tasarımını nasıl etkiler?</li>
    <li>Monolith vs Microservice → Dil ve framework tercihine etkisi</li>
    <li>API Gateway, Reverse Proxy, Load Balancer kavramları</li>
    <li>gRPC vs REST karşılaştırması</li>
    <li>Logging, Observability (metrics, tracing) ve dil seçimi</li>
  </ul>

  <p style="margin-top:3rem; font-size:0.85rem; color:#666;">
    Not: Bu dosya bir “iskelet” olarak tasarlandı. 
    Her bölümün altına kendi notlarını, örneklerini, diyagram linklerini ekleyebilirsin.
  </p>

</body>
</html>

