<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Backend Hızlı Rehber</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');

    :root {
      --bg: #0b1220;
      --panel: #111a2c;
      --panel-strong: #0d1728;
      --accent: #6ee7b7;
      --muted: #9ca3af;
      --text: #e5e7eb;
      --border: #1f2937;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Space Grotesk', 'Inter', system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(110, 231, 183, 0.08), transparent 26%), var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 0 1.5rem 3rem;
    }

    .shell {
      max-width: 1100px;
      margin: 0 auto;
      padding-top: 2rem;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 3vw, 2.4rem);
      letter-spacing: -0.02em;
    }

    p.lead {
      margin: 0;
      color: var(--muted);
      max-width: 720px;
    }

    nav.menu {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(11, 18, 32, 0.92);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.5rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 1.2rem;
    }

    nav.menu a {
      color: var(--text);
      text-decoration: none;
      padding: 0.55rem 0.9rem;
      border-radius: 10px;
      border: 1px solid transparent;
      background: var(--panel);
      transition: all 150ms ease;
      font-weight: 600;
      font-size: 0.95rem;
    }

    nav.menu a:hover {
      border-color: var(--accent);
      color: #0f172a;
      background: var(--accent);
    }

    section {
      background: var(--panel-strong);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.2rem 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
    }

    section h2 {
      margin-top: 0;
      margin-bottom: 0.65rem;
      letter-spacing: -0.01em;
    }

    section h3 {
      margin-top: 1.1rem;
      margin-bottom: 0.35rem;
    }

    .grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      background: rgba(110, 231, 183, 0.12);
      color: var(--text);
      border: 1px solid rgba(110, 231, 183, 0.35);
      font-size: 0.85rem;
      font-weight: 600;
    }

    ul {
      margin: 0.3rem 0;
      padding-left: 1.1rem;
      color: var(--muted);
    }

    li + li {
      margin-top: 0.25rem;
    }

    .muted {
      color: var(--muted);
    }

    .pill-list {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      margin: 0.4rem 0 0;
    }

    .callout {
      border-left: 4px solid var(--accent);
      padding-left: 0.75rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <h1>Backend Hızlı Rehber</h1>
      <p class="lead">
        Modern backend için dil seçimleri ve kavramlar. Hafif, sahada işe yarar bir özet; ağır mimari detaylar ve kernel tartışmaları yok.
      </p>
    </header>

    <nav class="menu">
      <a href="#diller">Diller</a>
      <a href="#veri-tabani">Veri Tabanı</a>
      <a href="#kavramlar">Backend Kavramları</a>
      <a href="#haric">Kapsam Dışı</a>
      <a href="#not">Not</a>
    </nav>

    <section id="diller">
      <h2>Diller ve Nerede Parlar</h2>
      <div class="grid">
        <div class="card">
          <h3>JavaScript / Node.js</h3>
          <p class="muted">Modern API, realtime, hızlı geliştirme.</p>
          <ul>
            <li><strong>Kullan:</strong> Realtime (WebSocket), çok I/O’lu API’ler.</li>
            <li><strong>Güçlü:</strong> Tek dilde (JS/TS) uçtan uca, devasa paket ekosistemi.</li>
            <li><strong>Dikkat:</strong> CPU-bound işlerde tıkanır; worker/thread offload gerek.</li>
          </ul>
        </div>
        <div class="card">
          <h3>TypeScript</h3>
          <p class="muted">JavaScript'in tipli hali → backend için daha güvenli.</p>
          <ul>
            <li><strong>Kullan:</strong> Node.js projelerinde hata payını azaltmak.</li>
            <li><strong>Güçlü:</strong> Refactor güveni, IDE otomasyonu, kontrat netliği.</li>
            <li><strong>Dikkat:</strong> Build/tsconfig disiplini şart; tip tanımları güncel kalmalı.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Golang (Go)</h3>
          <p class="muted">Basit, hızlı, cloud-native, microservice dostu.</p>
          <ul>
            <li><strong>Kullan:</strong> Yüksek trafikli API, altyapı/DevOps araçları.</li>
            <li><strong>Güçlü:</strong> Goroutine’ler, tek binary deploy, hız ve sadelik.</li>
            <li><strong>Dikkat:</strong> Generics sınırlı; framework yerine kütüphane toplarsın.</li>
          </ul>
        </div>
        <div class="card">
          <h3>C# / .NET Core</h3>
          <p class="muted">Kurumsal backend, güçlü API mimarisi, cross-platform.</p>
          <ul>
            <li><strong>Kullan:</strong> Enterprise API, yüksek güvenlik, uzun soluklu projeler.</li>
            <li><strong>Güçlü:</strong> ASP.NET Core pipeline, DI, tooling, Windows/Linux sorunsuz.</li>
            <li><strong>Dikkat:</strong> Runtime boyutu; bazı senaryolarda container imajı büyük.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Python</h3>
          <p class="muted">Hafif API (Flask/FastAPI), data &amp; automation.</p>
          <ul>
            <li><strong>Kullan:</strong> Prototip, AI/ML servisleri, script + API birleşimi.</li>
            <li><strong>Güçlü:</strong> Zengin bilimsel ekosistem, basitlik.</li>
            <li><strong>Dikkat:</strong> CPU-bound için yavaş; async yapıda dikkatli ol.</li>
          </ul>
        </div>
        <div class="card">
          <h3>PHP</h3>
          <p class="muted">Laravel ile klasik web backend kültürü.</p>
          <ul>
            <li><strong>Kullan:</strong> CRUD ağırlıklı web app, monolith hızlı çıkarma.</li>
            <li><strong>Güçlü:</strong> Laravel ekosistemi, hosting kolaylığı.</li>
            <li><strong>Dikkat:</strong> Yüksek performans için opcache/queue tuning gerek.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Ruby</h3>
          <p class="muted">Rails → modern web framework kültürünün kurucusu.</p>
          <ul>
            <li><strong>Kullan:</strong> Ürün odaklı SaaS, CRUD + dashboard.</li>
            <li><strong>Güçlü:</strong> Convention over configuration, hızlı MVP.</li>
            <li><strong>Dikkat:</strong> Yüksek trafik için scaling ve background job stratejisi şart.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Elixir</h3>
          <p class="muted">Erlang VM üzerinde yüksek concurrency.</p>
          <ul>
            <li><strong>Kullan:</strong> Realtime, messaging, fault-tolerant servisler.</li>
            <li><strong>Güçlü:</strong> BEAM dayanıklılığı, milyonlarca lightweight process.</li>
            <li><strong>Dikkat:</strong> Ekipte BEAM deneyimi gerek; ekosistem görece niş.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Kotlin</h3>
          <p class="muted">Java ekosisteminin modern alternatifi. Backend + Android desteği.</p>
          <ul>
            <li><strong>Kullan:</strong> JVM üzerinde modern backend; Android + backend aynı dil.</li>
            <li><strong>Güçlü:</strong> Spring ile uyum, Ktor ile hafif API.</li>
            <li><strong>Dikkat:</strong> JVM tuning bilgisi gerekir; build sürelerini optimize et.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="veri-tabani">
      <h2>SQL ve Veri Tabanı Ekosistemi</h2>
      <p class="muted">Backend kası = DB kası. Ne zaman hangisini kullanacağın:</p>
      <div class="grid">
        <div class="card">
          <h3>PostgreSQL</h3>
          <ul>
            <li><strong>Kullan:</strong> Varsayılan seçimin; güçlü SQL, JSONB, extension.</li>
            <li><strong>Güçlü:</strong> ACID, zengin index tipleri, CTE.</li>
            <li><strong>Dikkat:</strong> Replikasyon/partition planı kur; vacuum ayarlarını takip et.</li>
          </ul>
        </div>
        <div class="card">
          <h3>MySQL / MariaDB</h3>
          <ul>
            <li><strong>Kullan:</strong> LAMP mirası, hazır managed servisler.</li>
            <li><strong>Güçlü:</strong> Yaygın hosting, basit kullanım.</li>
            <li><strong>Dikkat:</strong> Versiyon/engine (InnoDB) seçimine bak; bazı gelişmiş SQL özellikleri kısıtlı.</li>
          </ul>
        </div>
        <div class="card">
          <h3>SQLite</h3>
          <ul>
            <li><strong>Kullan:</strong> Tek dosya, edge, mobil, prototip.</li>
            <li><strong>Güçlü:</strong> Sıfır ops, basit dağıtım.</li>
            <li><strong>Dikkat:</strong> Yüksek concurrency yok; sunucu modunda değil.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Redis</h3>
          <ul>
            <li><strong>Kullan:</strong> Cache, rate limit, queue/counter.</li>
            <li><strong>Güçlü:</strong> In-memory hız, TTL, pub/sub.</li>
            <li><strong>Dikkat:</strong> RAM maliyeti; persistence modunu ihtiyaca göre ayarla.</li>
          </ul>
        </div>
        <div class="card">
          <h3>MongoDB</h3>
          <ul>
            <li><strong>Kullan:</strong> Esnek şema, doküman tabanlı veri.</li>
            <li><strong>Güçlü:</strong> Hızlı iterasyon, nested veri modelleme.</li>
            <li><strong>Dikkat:</strong> Şema disiplini kaybolursa teknik borç birikir; index stratejisi şart.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="kavramlar">
      <h2>Backend Temel Kavramları</h2>
      <div class="grid">
        <div class="card">
          <h3>Request–Response Cycle</h3>
          <p class="muted">Client → Server → DB → Server → Client akışı. Monitoring’de trace’lemek kritik.</p>
        </div>
        <div class="card">
          <h3>Routing</h3>
          <p class="muted">URL → handler. REST/GraphQL entry noktası; versiyonlama (v1/v2) unutma.</p>
        </div>
        <div class="card">
          <h3>Middleware</h3>
          <p class="muted">Auth, logging, rate limit, error handler, session, body parser; sıralama önemlidir.</p>
        </div>
        <div class="card">
          <h3>Controller / Handler</h3>
          <p class="muted">İsteği alır, iş mantığını çalıştırır, yanıtı hazırlar; slim controller, service katmanı ekle.</p>
        </div>
        <div class="card">
          <h3>ORM / Query Builder</h3>
          <p class="muted">Tabloyu koda map eder. Prisma, Entity Framework, Django ORM, Eloquent, Hibernate, TypeORM.</p>
        </div>
        <div class="card">
          <h3>API Türleri</h3>
          <p class="muted">REST (genel), GraphQL (esnek client), gRPC (performans/contract), WebSocket (realtime).</p>
        </div>
        <div class="card">
          <h3>I/O-bound vs CPU-bound</h3>
          <p class="muted">I/O dış kaynağı bekler; CPU hesap yapar. Node için I/O, Go/.NET için karma yükler.</p>
        </div>
        <div class="card">
          <h3>Concurrency</h3>
          <p class="muted">Birden fazla işin ilerlemesi; event loop, goroutine, thread pool ile planlanır.</p>
        </div>
        <div class="card">
          <h3>Parallelism</h3>
          <p class="muted">Aynı anda çekirdeklerde çalışma; CPU-bound işleri hızlandırır, CPU sayısına bağlı.</p>
        </div>
        <div class="card">
          <h3>Framework Mantığı</h3>
          <p class="muted">Routing + middleware + controller + config + DI. Standartlaştırır, tekrar eden işleri çözer.</p>
        </div>
        <div class="card">
          <h3>Monolith vs Microservice</h3>
          <p class="muted">Monolith = tek app, kolay başla; Microservice = bağımsız servis, dağıtık karmaşıklık.</p>
        </div>
        <div class="card">
          <h3>Scaling</h3>
          <p class="muted">Vertical: CPU/RAM artır. Horizontal: instance çoğalt, load balancer ekle.</p>
        </div>
        <div class="card">
          <h3>Caching</h3>
          <p class="muted">Redis, Memcached ile sıcak veri; cache invalidation stratejisi belirle.</p>
        </div>
        <div class="card">
          <h3>Environment &amp; Config</h3>
          <p class="muted">.env, secrets yönetimi, ortam bazlı config; prod/stage/dev ayrımı net olsun.</p>
        </div>
      </div>
    </section>

    <section id="haric">
      <h2>Kapsama Girmeyenler</h2>
      <p class="muted">Boğucu detaylar burada yok:</p>
      <ul>
        <li>Garbage collector derinliği, thread pool mimarisi</li>
        <li>JIT/AOT farkı, memory modeli, assembly-level konular</li>
        <li>Linux kernel scheduling, K8s deep dive</li>
        <li>Reactive programming detayları, CAP theorem teknik analizi</li>
      </ul>
    </section>

    <section id="not">
      <h2>Not</h2>
      <div class="callout">
        Swift, Objective-C gibi diller backend dünyasının ana konseptine girmiyor; dokümana eklenmedi.
      </div>
    </section>

    <section id="teknik-kavramlar">
      <h2>Teknik Kavramlar (Mühendis Seviyesi)</h2>
      <div class="grid">
        <div class="card">
          <h3>CPU-bound</h3>
          <p class="muted">CPU-bound iş yükü, sürenin çoğunu işlemci hesaplamalarında harcayan, I/O beklemeyen görevlerdir. Bu tür işlerde performans, çekirdek sayısı, saat hızı ve SIMD gibi CPU özelliklerine bağlıdır. Paralelleştirme yapılmadıysa tek çekirdek hızının tavanı belirler; algoritma karmaşıklığı kritik hale gelir. Dil/runtime’ın scheduler ve thread modeli, CPU-bound işin ölçeklenebilirliğini doğrudan etkiler. Profiling ve hot path optimizasyonu bu iş yüklerinde en yüksek getiriyi sağlar.</p>
        </div>
        <div class="card">
          <h3>I/O-bound</h3>
          <p class="muted">I/O-bound iş yükü, zamanın çoğunu disk, ağ, DB veya diğer harici kaynakları bekleyerek geçirir. Burada darboğaz CPU değil, gecikmesi yüksek olan I/O operasyonlarıdır. Async/event-driven modeller bu bekleme sürelerini overlap ederek throughput’u yükseltir. Connection pooling, batching ve caching I/O-bound sistemleri iyileştirir. Kuyruklar ve backpressure mekanizmaları I/O beklerken sistemi dengede tutar.</p>
        </div>
        <div class="card">
          <h3>CPU’nun Programlama Dillerinde Kullanımı (Threading Modeli)</h3>
          <p class="muted">Programlama dilleri CPU’yu OS threadleri veya kullanıcı seviyesi lightweight threadler üzerinden kullanır. C#, Java ve benzeri dillerde OS threadleri bir thread pool ile yönetilir; her thread doğrudan çekirdek zamanlayıcısına bağlanır. Node.js tek ana thread üstünde event loop çalıştırır, CPU işleri için worker thread pool’a offload eder. Go’da goroutine’ler kullanıcı seviyesi scheduler ile az sayıda OS threadine dağıtılır; M:N modeli CPU’yu verimli kullanır. Scheduler’ın work-stealing ve load balancing stratejisi CPU çekirdeklerinin doluluk oranını belirler.</p>
        </div>
        <div class="card">
          <h3>RAM Kullanımı (Heap, Stack, GC)</h3>
          <p class="muted">Stack, fonksiyon çağrılarının lokal değişkenleri ve dönüş adresleri için ayrılmış, LIFO düzenli hızlı bellek alanıdır. Heap, dinamik ömrü olan nesneler için kullanılır; fragmentasyon ve tahsis maliyeti stack’ten yüksektir. GC’li dillerde heap nesneleri işaretleme-süpürme veya kopyalama gibi algoritmalarla otomatik temizlenir; GC duraklamaları latency’yi etkiler. Rust/C++ gibi manuel/ownership tabanlı dillerde geliştirici yaşam döngüsünü belirler; hatalar double free veya leak’e yol açabilir. Arena/stack allocation gibi stratejiler heap baskısını azaltıp cache locality’yi iyileştirir.</p>
        </div>
        <div class="card">
          <h3>Concurrency</h3>
          <p class="muted">Concurrency, birden fazla iş biriminin zaman dilimleri paylaşarak ilerlemesidir; aynı anda başlamış gibi görünür, paralellik şart değildir. Amaç throughput’u ve kaynak kullanımını yükseltmektir; scheduler işler arasında geçiş yapar. Ortak state varsa race condition, deadlock, starvation riskleri doğar; lock, mutex, semaphore veya mesaj geçirme ile kontrol edilir. Dil ve runtime, concurrency primitifleri (goroutine, async/await, futures) ve memory modeli ile bu güvenliği tanımlar. Doğru tasarım, izolasyon ve immutable veri ile contention’ı minimize eder.</p>
        </div>
        <div class="card">
          <h3>Parallelism</h3>
          <p class="muted">Parallelism, birden fazla çekirdekte gerçekten aynı anda çalışmadır; CPU-bound işleri hızlandırmak için kullanılır. Görevler bölünebilir olmalı; veri bağımlılıkları veya paylaşılan kilitler hız kazancını yok edebilir. SIMD/SIMT veya çok çekirdek kullanımı paralelliğin donanım katmanlarıdır. Work stealing ve load balancing, çekirdekler arasında iş dağıtımını optimize eder. Amdahl ve Gustafson yasaları, paralelliğin teorik sınırlarını özetler.</p>
        </div>
        <div class="card">
          <h3>Blocking vs Non-blocking</h3>
          <p class="muted">Blocking çağrıda thread, I/O tamamlanana kadar durur; thread havuzu dar ise throughput düşer. Non-blocking çağrıda I/O başlatılır, tamamlanınca callback/promise/future ile sonuç gelir; thread beklemez. Event-driven sunucular non-blocking I/O ile daha az thread ile daha çok bağlantı tutar. CPU-bound işleri non-blocking modelde de offload etmek gerekir, aksi halde event loop tıkanır. Doğru backpressure olmadan non-blocking sistemler de aşırı yükte boğulabilir.</p>
        </div>
        <div class="card">
          <h3>Throughput vs Latency</h3>
          <p class="muted">Throughput, birim zamanda tamamlanan iş miktarıdır; RPS veya TPS ile ölçülür. Latency, tek bir isteğin tamamlanma süresidir; p50/p95/p99 değerleri önemlidir. Yüksek throughput optimizasyonu genellikle batching, queueing, non-blocking I/O ile yapılır. Düşük latency için kuyruk derinliğini sınırlamak, GC duraklarını azaltmak ve sıcak cache kullanmak gerekir. Sistem tasarımında bu iki metrik çoğu zaman gerilim içindedir; hedefe göre trade-off yapılır.</p>
        </div>
        <div class="card">
          <h3>Synchronous vs Asynchronous</h3>
          <p class="muted">Synchronous modelde iş çağrısı sonuçlanana kadar akış bekler; kontrol akışı daha basittir. Asynchronous modelde çağrı tetiklenir, sonuç hazır olunca callback/promise/await ile devam edilir. I/O-bound sistemlerde async, aynı thread ile daha fazla bekleyen işi yöneterek kaynak verimliliği sağlar. CPU-bound işlerde async tek başına hız kazandırmaz; paralel yürütme veya offload gerekir. Hata ve kontrol akışı yönetimi async yapılarda daha karmaşıktır; structured concurrency bunu sadeleştirmeyi hedefler.</p>
        </div>
        <div class="card">
          <h3>Event Loop (Node.js)</h3>
          <p class="muted">Node.js event loop’u tek ana thread üzerinde çalışır ve iş kuyruğunu sürekli döner. I/O işlemleri OS’ye offload edilir, tamamlanınca callback/promise microtask/macro task kuyruklarına eklenir. CPU-bound işler ana thread’de yürürse loop bloklanır ve tüm isteklerin latency’si artar. Ağır işleri worker_threads veya ayrı servislere taşımak, event loop’u I/O koordinatörü olarak tutar. Libuv, timer, I/O poll, check gibi fazlarla loop’un adımlarını yönetir.</p>
        </div>
        <div class="card">
          <h3>Goroutine Scheduler (Go)</h3>
          <p class="muted">Go, M:N modeliyle binlerce goroutine’i az sayıda OS threadine dağıtır. Scheduler, work stealing yaparak runnable queue’lardan işleri çekirdekler arası dengeler. Syscall veya uzun bloklamada goroutine park edilir, başka bir goroutine aynı OS thread’inde çalıştırılır. GOMAXPROCS, aynı anda kaç OS thread’inin CPU üzerinde koşacağını sınırlar. Preemptive scheduling sayesinde uzun süren goroutine’ler diğerlerini aç bırakmaz.</p>
        </div>
        <div class="card">
          <h3>Thread Pool (C#, Java)</h3>
          <p class="muted">C# ve Java’da thread pool, yeniden kullanılabilir OS thread’leriyle görev kuyruğunu tüketir. Pool, minimum ve maksimum thread sayısı, bekleme kuyrukları ve work stealing stratejileriyle ayarlanır. I/O-bound async modellerinde thread bloklamayı azaltmak için async/await veya CompletableFuture kullanılır. CPU-bound işler için Task/Executor üstünde paralel iş dağıtılır; fazla thread oversubscription’a ve context switch yüküne yol açar. Pool’un metriklerini (queue depth, active threads) izlemek tuning için şarttır.</p>
        </div>
      </div>
    </section>
  </div>
</body>
</html>
